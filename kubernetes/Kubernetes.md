# Kubernetes

### Fundamental K8 Components

| Component       | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|-----------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Node**        | A simple server (or worker server). There are two types of node: master and slave                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| **Pod**         | The smallest unit of K8s, a simple abstraction over a container (want to abstract away the container technology e.g. Docker); usually a pod contains one application container but it can be the case that a pod has multiple containers. Each pod has its own virtual IP address (not the container), however, pod components are *ephemeral* so they can die easily (e.g. container crashes because run out of resource) but then they get a assigned a new IP address. There are **replica** pods so if an individual pod goes down then we load balance across replica pods via the service. In effect, when we define a pod we are specifying a blueprint | 
| **Service**     | a service has a permanent IP address and the lifecycle of a pod and service are different so if the pod dies then the service IP address remains the same. Pods (and replicas) communicate via services so we can think of the service like a load-balancer. , Kubernetes services are themselves the crudest form of load balancing traffic. In Kubernetes the most basic type of load balancing is load distribution.                                                                                                                                                                                                                                        |
|                 | **External service** can be accessed directly from outside the pod via IP address (so we can use this for testing)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | 
|                 | **Internal service** cannot be accessed outside the pod                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | 
| **Ingress**     | An ingress is used to route traffic into the Kubernetes cluster and typically forwards to a service via a domain (not IP) e.g http://my-app.com                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |                                                                                                                                |
| **Deployment**  | A deployment is an abstraction on top of pods. A deployment is the blueprint for a **stateless* pod so in the deployment we can specify things like how many replicas we want. In practice, we tend to work with deployments rather than pods                                                                                                                                                                                                                                                                                                                                                                                                                  |
| **ConfigMap**   | Provides external configuration of the application (e.g. database urls etc)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | 
| **Secret**      | The secret is just like configMap but is used to store sensitive data (e.g. credentials and keys) and is not stored in plain text but is encoded using Base64. We connect the secret to the pod so it can read the sensitive data                                                                                                                                                                                                                                                                                                                                                                                                                              | 
| **Volumes**     | Volumes attach physical storage on a machine to a pod (could be cloud storage or local storage) so data persists if the pod shuts down. Kubernetes does not manage any data persistence so you are responsible for backing up volumes                                                                                                                                                                                                                                                                                                                                                                                                                          |
| **StatefulSet** | A StatefulSet is another type of pod blueprint but is a stateful alternative to a stateless Deployment. A pod which contains a database cannot be replicated - each of the replica pods must talk to the same db - so pods which contain a stateful element (such as a DB) are called StatefulSet. Because deploying StatefulSet can be more challenging it is not uncommon to have stateful services such as DBs, ELK etc to live outside the Kubernetes cluster                                                                                                                                                                                              | 


### Node Processes
Kubernetes is built on the idea of master and worker nodes. There are 3 processes which need to run on every worker node:

- **Container runtime** (could be Docker) plays a crucial role in managing and executing containers. It is responsible for interacting with the underlying operating system's kernel and providing the necessary functionality to start, stop, and manage containers within a Kubernetes cluster. The container runtime acts as an intermediary between Kubernetes and the actual containers, abstracting away the complexities of containerization and enabling Kubernetes to handle containerized applications efficiently. Its main responsibilities are:
  - **Container Management**: The runtime is responsible for creating/managing containers. It pulls container images from container registries (like Docker Hub or a private registry), creates containers based on those images, and starts or stops them as needed.
  - **Namespace and Isolation**: Kubernetes uses Linux namespaces to provide process-level isolation for containers. The container runtime sets up and manages these namespaces, ensuring that each container in the cluster is isolated from others, including networking, process space, filesystem, and user IDs.
  - **Container Networking**: The container runtime is involved in configuring networking for containers. It sets up network bridges, virtual Ethernet interfaces, and iptables rules to allow containers to communicate with each other and with external services.
  - **Resource Constraints**: Kubernetes allows you to set resource constraints (such as CPU and memory limits) for containers. The container runtime enforces these constraints by interacting with the kernel's cgroups (control groups) to ensure that containers don't exceed their allocated resources.
  - **Container Health Monitoring**: The container runtime provides an interface for Kubernetes to monitor the health of containers. Kubernetes periodically checks the status of containers through the container runtime to ensure they are running correctly and can take appropriate actions in case of failures.
  - **Image Management**: The container runtime handles the storage and caching of container images. When Kubernetes schedules a pod, the container runtime ensures that the required container images are available locally on the node. If not present, it pulls the images from the container registry.


- **Kubelet** schedules the pod an it interfaces with the node itself and the container runtime. Kubelet starts the pod and assigns resources (e.g. CPU, memory and storage) to it. Its main responsibilities are:
  - **Pod Management**: The kubelet is primarily responsible for managing pods on its node. It receives pod definitions from the API server, and then it takes care of instantiating the containers specified in those pods. It ensures that the desired state of the pods matches the actual state by starting, stopping, and restarting containers as necessary.
  - **Container Management**: The kubelet interacts with the container runtime (e.g., Docker, containerd, or CRI-O) to manage the lifecycle of containers. It starts and stops containers, monitors their health, and restarts them if they fail. It also handles container image pulling from container registries if needed.
  - **Node Status Updates**: The kubelet is responsible for reporting the status of the node and its containers back to the control plane. It regularly communicates with the Kubernetes API server to update the node's status, including information about available resources (CPU, memory, etc.) and the conditions of running pods.
  - **Volume Management**: The kubelet handles attaching and mounting volumes specified in pod definitions. It ensures that the required volumes are available and properly mounted inside containers.
  - **Pod Networking**: The kubelet works in conjunction with the container runtime to set up networking for containers. It ensures that each pod has a unique IP address and that containers within the same pod can communicate with each other over the local network.
  - **Node Eviction**: In case of resource pressure or failures, the kubelet can initiate node eviction processes, which gracefully terminate running pods on a node to free up resources or ensure proper rescheduling.
  - **Handling Node-Level Configurations**: The kubelet can be configured with various node-level parameters, such as setting maximum pod density, managing system-level containers, and applying node-specific configurations.


- **Kubeproxy** responsible for enabling communication between different services and pods within the cluster. Its primary role is to facilitate networking operations (e.g. forwarding requests), allowing seamless connectivity and load balancing for services running on Kubernetes. Its main responsibilities are:
  - **Service Discovery**: When you create a Kubernetes Service, it is assigned a virtual IP address. This virtual IP is used to expose the service internally within the cluster. The kube-proxy watches for changes in the service and endpoint configurations and updates the internal network rules (iptables or IPVS rules, depending on the mode) to ensure that incoming requests to the virtual IP are correctly forwarded to the appropriate backend pods. 
  - **Load Balancing**: In cases where multiple pods are running for a given service, kube-proxy ensures that incoming network traffic to the service's virtual IP is distributed evenly across these pods. This load balancing helps distribute the workload and prevent any single pod from being overwhelmed with traffic. 
  - **IP Masquerading**: In certain network setups, pods running on a node might not have direct external access. Kube-proxy handles the necessary IP masquerading (NAT - Network Address Translation) so that when a pod sends a request to an external IP, the response from the external network is routed back to the correct pod. 
  - **High Availability**: kube-proxy itself can be run in different modes to ensure high availability. For example, you can configure it to run in either userspace mode, iptables mode, or IPVS (IP Virtual Server) mode. IPVS mode is often preferred for better performance and scalability in large clusters.


### Master Processes

- Master nodes are responsible for scheduling pods, monitoring pods and rescheduling/restarting pods. There are 4 master services which run on every master node to control the cluster state and the worker nodes:


- **API Server** is  primary control panel element responsible for serving the Kubernetes API and acts as a sort of cluster gateway. It acts as the front-end and provides a central point for managing and interacting with the cluster. All administrative operations, as well as user and automated interactions with the cluster, are mediated through the API server. Its main responsibilities are:
  - **Exposing the Kubernetes API**: The API server exposes a RESTful HTTP API that allows clients (such as kubectl, kubelet, controllers, and custom applications) to interact with the cluster. This API is the main interface for managing resources within the cluster, such as pods, services, deployments, and more.
  - **Authenticating and Authorizing Requests**: The API server handles authentication/authorization for incoming requests. It verifies the identity of clients (users or automated processes) and checks their permissions against the configured RBAC (Role-Based Access Control) policies to determine if the requested action is allowed.
  - **Validating and Accepting Resource Definitions**: When users or automated processes create or update Kubernetes resources (e.g., pods, services, or config maps) through the API server, it performs validation checks to ensure the submitted resource definitions are well-formed and adhere to any schema constraints.
  - **Request Routing and Load Balancing**: The API server acts as a load balancer for requests coming from various clients. It routes requests to the appropriate components of the control plane, such as the [etcd datastore](https://etcd.io/), the scheduler, the controller manager, and the kubelet.
  - **Managing Cluster State**: The API server stores the cluster's desired state in the etcd datastore, a distributed key-value store. It receives requests to change the cluster's state, validates them, and then stores the desired changes in etcd. The other components of the control plane read from etcd to understand the desired state and take actions to maintain that state.
  - **Serving Admission Controllers**: Admission controllers are plugins that intercept and process requests before they are persisted to etcd or before a response is returned to the client. The API server invokes these admission controllers for various purposes, such as enforcing custom policies, validating requests, and modifying resource definitions.
  - **Providing API Extensions**: The API server supports custom resource definitions (CRDs) and custom controllers, enabling users to extend Kubernetes with their own custom resources and associated logic.

- **Scheduler**

